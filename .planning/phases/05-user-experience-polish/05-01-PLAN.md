---
phase: 05-user-experience-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - addons/spora_segment/models/sale_order_segment.py
autonomous: true

must_haves:
  truths:
    - "Segment displays full hierarchical path (e.g., 'Phase 1 / Materials / Flyers')"
    - "Segment shows maximum depth of descendant tree (0 = leaf, 1+ = has descendants)"
    - "Segment shows count of products directly assigned to it"
    - "Child count is stored in database for instant reads"
  artifacts:
    - path: "addons/spora_segment/models/sale_order_segment.py"
      provides: "Computed fields: full_path, child_depth, product_count, child_count with store=True"
      contains: "def _compute_full_path"
  key_links:
    - from: "full_path"
      to: "parent_id.full_path"
      via: "recursive=True @api.depends"
      pattern: "@api.depends\\('name', 'parent_id.full_path'\\)"
    - from: "child_depth"
      to: "child_ids.child_depth"
      via: "recursive=True @api.depends"
      pattern: "@api.depends\\('child_ids', 'child_ids.child_depth'\\)"
---

<objective>
Add UX-optimized computed fields to sale.order.segment model

Purpose: Enable visual hierarchy feedback and efficient navigation by adding full_path breadcrumb, child_depth for smart button, and product_count for list view display.

Output: Enhanced sale_order_segment.py with 4 computed fields (full_path, child_depth, product_count, child_count updated with store=True)
</objective>

<execution_context>
@/Users/juanmanuelojedagarcia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juanmanuelojedagarcia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-user-experience-polish/05-CONTEXT.md
@.planning/phases/05-user-experience-polish/05-RESEARCH.md
@addons/spora_segment/models/sale_order_segment.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add full_path computed field</name>
  <files>addons/spora_segment/models/sale_order_segment.py</files>
  <action>
Add computed field `full_path` to SaleOrderSegment model:

1. Add field declaration after `child_count`:
```python
full_path = fields.Char(
    string='Full Path',
    compute='_compute_full_path',
    recursive=True,
    store=True,
    help='Full hierarchical path: "Root / Parent / This Segment"',
)
```

2. Add compute method:
```python
@api.depends('name', 'parent_id.full_path')
def _compute_full_path(self):
    """Compute full hierarchical breadcrumb path."""
    for segment in self:
        if segment.parent_id:
            segment.full_path = '%s / %s' % (segment.parent_id.full_path, segment.name)
        else:
            segment.full_path = segment.name
```

Key patterns from RESEARCH.md:
- Use `recursive=True` parameter on field definition (required for cascading updates)
- Depend on `parent_id.full_path` (not just parent_id) to trigger recomputation on ancestor name changes
- Use `store=True` for instant reads (user decision: prioritize read performance)
  </action>
  <verify>
Run Odoo shell to test:
```bash
docker compose exec odoo odoo shell -d odoo --no-http -c /etc/odoo/odoo.conf
```
Then in shell:
```python
seg = env['sale.order.segment'].search([], limit=1)
print(seg.full_path)
```
  </verify>
  <done>Segment shows full_path with "/" separator, cascades when parent name changes</done>
</task>

<task type="auto">
  <name>Task 2: Add child_depth and product_count fields, update child_count</name>
  <files>addons/spora_segment/models/sale_order_segment.py</files>
  <action>
Add two more computed fields and update child_count:

1. Update `child_count` field to add `store=True`:
```python
child_count = fields.Integer(
    string='Sub-segment Count',
    compute='_compute_child_count',
    store=True,  # Added for performance
    help='Number of direct child segments',
)
```

2. Add `child_depth` field after `child_count`:
```python
child_depth = fields.Integer(
    string='Depth Levels',
    compute='_compute_child_depth',
    recursive=True,
    store=True,
    help='Maximum depth of descendant tree (0 = leaf, 1+ = has descendants)',
)
```

3. Add compute method for `child_depth`:
```python
@api.depends('child_ids', 'child_ids.child_depth')
def _compute_child_depth(self):
    """Compute maximum depth of descendant tree.

    Recursive dependency ensures bottom-up recomputation when
    hierarchy structure changes.
    """
    for segment in self:
        if not segment.child_ids:
            segment.child_depth = 0
        else:
            segment.child_depth = max(segment.child_ids.mapped('child_depth')) + 1
```

4. Add `product_count` field:
```python
product_count = fields.Integer(
    string='Product Count',
    compute='_compute_product_count',
    store=True,
    help='Number of products directly assigned to this segment (not children)',
)
```

5. Add compute method for `product_count`:
```python
@api.depends('line_ids')
def _compute_product_count(self):
    """Count products assigned to this segment (not children)."""
    for segment in self:
        segment.product_count = len(segment.line_ids)
```

Key patterns from RESEARCH.md:
- `child_depth` uses `recursive=True` for bottom-up cascade recomputation
- `product_count` counts only direct line_ids, NOT children (user decision)
- All fields use `store=True` per user decision (prioritize read performance)
  </action>
  <verify>
Run Odoo shell to test:
```python
# Create test hierarchy if needed
seg = env['sale.order.segment'].search([('child_ids', '!=', False)], limit=1)
print(f"child_count: {seg.child_count}, child_depth: {seg.child_depth}, product_count: {seg.product_count}")
# Verify: leaf segments have child_depth=0, parents have child_depth >= 1
```
  </verify>
  <done>Segments have child_depth (0 for leaves, 1+ for parents), product_count shows line_ids count, child_count is stored</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Upgrade module in Docker:
```bash
docker compose exec odoo odoo -d odoo -u spora_segment --stop-after-init -c /etc/odoo/odoo.conf
```

2. Test in Odoo shell:
```python
# Test full_path
root = env['sale.order.segment'].search([('parent_id', '=', False)], limit=1)
child = env['sale.order.segment'].search([('parent_id', '!=', False)], limit=1)
print(f"Root full_path: {root.full_path}")
print(f"Child full_path: {child.full_path}")

# Test child_depth
print(f"Root child_depth: {root.child_depth}")

# Test cascade: rename root and check child's full_path
old_name = root.name
root.name = 'RENAMED'
child.invalidate_recordset(['full_path'])
print(f"After rename: {child.full_path}")  # Should start with 'RENAMED'
root.name = old_name  # Restore
```

3. Verify database storage:
```sql
SELECT id, name, full_path, level, child_count, child_depth, product_count
FROM sale_order_segment LIMIT 5;
```
</verification>

<success_criteria>
- [ ] full_path shows complete hierarchy path with "/" separator
- [ ] full_path cascades when any ancestor name changes
- [ ] child_depth = 0 for leaves, 1+ for nodes with descendants
- [ ] product_count shows count of directly assigned order lines
- [ ] child_count is stored (not recomputed on read)
- [ ] Module upgrade succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-user-experience-polish/05-01-SUMMARY.md`
</output>
